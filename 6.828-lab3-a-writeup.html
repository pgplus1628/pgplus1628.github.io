<!DOCTYPE html>
<html lang="en" prefix="og: http://ogp.me/ns# fb: https://www.facebook.com/2008/fbml">
<head>
    <title>6.828 Lab3 PartA 小结 - Z's Thoughts</title>
    <!-- Using the latest rendering mode for IE -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">



<link rel="canonical" href="http://zorksylar.github.io/6.828-lab3-a-writeup.html">

        <meta name="author" content="zorksylar" />
        <meta name="keywords" content="[6.828,OS]" />
        <meta name="description" content="User Environments and Exception Handling" />

        <meta property="og:site_name" content="Z's Thoughts" />
        <meta property="og:type" content="article"/>
        <meta property="og:title" content="6.828 Lab3 PartA 小结"/>
        <meta property="og:url" content="http://zorksylar.github.io/6.828-lab3-a-writeup.html"/>
        <meta property="og:description" content="User Environments and Exception Handling"/>
        <meta property="article:published_time" content="2013-08-20" />
            <meta property="article:section" content="Blog" />
            <meta property="article:tag" content="[6.828" />
            <meta property="article:tag" content="OS]" />
            <meta property="article:author" content="zorksylar" />



    <!-- Bootstrap -->
        <link rel="stylesheet" href="http://zorksylar.github.io/theme/css/bootstrap.min.css" type="text/css"/>
    <link href="http://zorksylar.github.io/theme/css/font-awesome.min.css" rel="stylesheet">

    <link href="http://zorksylar.github.io/theme/css/pygments/manni.css" rel="stylesheet">
    <link rel="stylesheet" href="http://zorksylar.github.io/theme/css/style.css" type="text/css"/>

        <link href="http://zorksylar.github.io/feeds/all.atom.xml" type="application/atom+xml" rel="alternate"
              title="Z's Thoughts ATOM Feed"/>



        <link href="http://zorksylar.github.io/feeds/blog.atom.xml" type="application/atom+xml" rel="alternate"
              title="Z's Thoughts Blog ATOM Feed"/>

</head>
<body>

<div class="navbar navbar-default navbar-fixed-top" role="navigation">
	<div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a href="http://zorksylar.github.io/" class="navbar-brand">
Z's Thoughts            </a>
        </div>
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav">
                        <li class="active">
                            <a href="http://zorksylar.github.io/category/blog.html">Blog</a>
                        </li>
            </ul>
            <ul class="nav navbar-nav navbar-right">
              <li><a href="http://zorksylar.github.io/archives.html"><i class="fa fa-th-list"></i><span class="icon-label">Archives</span></a></li>
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
</div> <!-- /.navbar -->
<!-- Banner -->
<!-- End Banner -->
<div class="container">
    <div class="row">
        <div class="col-lg-12">
    <section id="content">
        <article>
            <header class="page-header">
                <h1>
                    <a href="http://zorksylar.github.io/6.828-lab3-a-writeup.html"
                       rel="bookmark"
                       title="Permalink to 6.828 Lab3 PartA 小结">
                        6.828 Lab3 PartA 小结
                    </a>
                </h1>
            </header>
            <div class="entry-content">
                <div class="panel">
                    <div class="panel-body">
<footer class="post-info">
    <span class="label label-default">Date</span>
    <span class="published">
        <i class="fa fa-calendar"></i><time datetime="2013-08-20T00:00:00+08:00"> Tue 20 August 2013</time>
    </span>





<span class="label label-default">Tags</span>
	<a href="http://zorksylar.github.io/tag/6828.html">[6.828</a>
        /
	<a href="http://zorksylar.github.io/tag/os.html">OS]</a>
    
</footer><!-- /.post-info -->                    </div>
                </div>
                <h3>User Environments and Exception Handling</h3>
<h3>Exercise 1</h3>
<ol>
<li>在JOS里面， struct Env 相当于是 linux kernel 里面的 task_struct，用于表示一个task。</li>
</ol>
<div class="highlight"><pre><span class="k">struct</span> <span class="n">Env</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">Trapframe</span> <span class="n">env_tf</span><span class="p">;</span>  <span class="c1">// Saved registers</span>
  <span class="k">struct</span> <span class="n">Env</span> <span class="o">*</span><span class="n">env_link</span><span class="p">;</span>   <span class="c1">// Next free Env</span>
  <span class="kt">envid_t</span> <span class="n">env_id</span><span class="p">;</span>     <span class="c1">// Unique environment identifier</span>
  <span class="kt">envid_t</span> <span class="n">env_parent_id</span><span class="p">;</span>    <span class="c1">// env_id of this env&#39;s parent</span>
  <span class="k">enum</span> <span class="n">EnvType</span> <span class="n">env_type</span><span class="p">;</span>    <span class="c1">// Indicates special system environments</span>
  <span class="kt">unsigned</span> <span class="n">env_status</span><span class="p">;</span>    <span class="c1">// Status of the environment</span>
  <span class="kt">uint32_t</span> <span class="n">env_runs</span><span class="p">;</span>    <span class="c1">// Number of times environment has run</span>

  <span class="c1">// Address space</span>
  <span class="kt">pde_t</span> <span class="o">*</span><span class="n">env_pgdir</span><span class="p">;</span>   <span class="c1">// Kernel virtual address of page dir</span>
<span class="p">};</span>
</pre></div>


<p>其中的 env_tf 用于保存当这个env的中间状态，恢复这个trapframe 就能够按照之前中断的地方继续执行了。如，进程切换的时候，env_tf 中保存着 task 运行所需要的各种寄存器的值。其中的 packed 表示取消编译器对结构体的优化对齐，取消优化对齐，结构体的访问速度可能会降低，这样做是为了和 Intel IA32 Manual 里面的 trapframe 保持一致。</p>
<div class="highlight"><pre><span class="k">struct</span> <span class="n">PushRegs</span> <span class="p">{</span>
  <span class="cm">/* registers as pushed by pusha */</span>
  <span class="kt">uint32_t</span> <span class="n">reg_edi</span><span class="p">;</span>
  <span class="kt">uint32_t</span> <span class="n">reg_esi</span><span class="p">;</span>
  <span class="kt">uint32_t</span> <span class="n">reg_ebp</span><span class="p">;</span>
  <span class="kt">uint32_t</span> <span class="n">reg_oesp</span><span class="p">;</span>    <span class="cm">/* Useless */</span>
  <span class="kt">uint32_t</span> <span class="n">reg_ebx</span><span class="p">;</span>
  <span class="kt">uint32_t</span> <span class="n">reg_edx</span><span class="p">;</span>
  <span class="kt">uint32_t</span> <span class="n">reg_ecx</span><span class="p">;</span>
  <span class="kt">uint32_t</span> <span class="n">reg_eax</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="k">struct</span> <span class="n">Trapframe</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">PushRegs</span> <span class="n">tf_regs</span><span class="p">;</span>
  <span class="kt">uint16_t</span> <span class="n">tf_es</span><span class="p">;</span>
  <span class="kt">uint16_t</span> <span class="n">tf_padding1</span><span class="p">;</span>
  <span class="kt">uint16_t</span> <span class="n">tf_ds</span><span class="p">;</span>
  <span class="kt">uint16_t</span> <span class="n">tf_padding2</span><span class="p">;</span>
  <span class="kt">uint32_t</span> <span class="n">tf_trapno</span><span class="p">;</span>
  <span class="cm">/* below here defined by x86 hardware */</span>
  <span class="kt">uint32_t</span> <span class="n">tf_err</span><span class="p">;</span>
  <span class="kt">uintptr_t</span> <span class="n">tf_eip</span><span class="p">;</span>
  <span class="kt">uint16_t</span> <span class="n">tf_cs</span><span class="p">;</span>
  <span class="kt">uint16_t</span> <span class="n">tf_padding3</span><span class="p">;</span>
  <span class="kt">uint32_t</span> <span class="n">tf_eflags</span><span class="p">;</span>
  <span class="cm">/* below here only when crossing rings, such as from user to kernel */</span>
  <span class="kt">uintptr_t</span> <span class="n">tf_esp</span><span class="p">;</span>
  <span class="kt">uint16_t</span> <span class="n">tf_ss</span><span class="p">;</span>
  <span class="kt">uint16_t</span> <span class="n">tf_padding4</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>
</pre></div>


<p>为了管理所有的Env，在JOS里面，维护了三个变量:</p>
<div class="highlight"><pre><span class="k">struct</span> <span class="n">Env</span> <span class="o">*</span><span class="n">envs</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>    <span class="c1">// All environments</span>
<span class="k">struct</span> <span class="n">Env</span> <span class="o">*</span><span class="n">curenv</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>    <span class="c1">// The current env</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">Env</span> <span class="o">*</span><span class="n">env_free_list</span><span class="p">;</span> <span class="c1">// Free environment list</span>
</pre></div>


<p>在 JOS 中，所有的 struct Env 都是通过 envs 这个全局的变量维护的，envs 是一个 struct Env 的数组。在 mem_init()的时候，同时初始化 envs。同时为了能够让 user 态能够访问自己的 Env ，所以需要在 kern_pgdir 中映射 UENVS 到 envs，同时权限是对 user RO 的。</p>
<div class="highlight"><pre><span class="c1">// Make &#39;envs&#39; point to an array of size &#39;NENV&#39; of &#39;struct Env&#39;.</span>
<span class="c1">// LAB 3: Your code here.</span>
<span class="n">envs</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">Env</span> <span class="o">*</span><span class="p">)</span><span class="n">boot_alloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">Env</span><span class="p">)</span> <span class="o">*</span> <span class="n">NENV</span><span class="p">);</span>

<span class="c1">// Map the &#39;envs&#39; array read-only by the user at linear address UENVS</span>
<span class="c1">// (ie. perm = PTE_U | PTE_P).</span>
<span class="c1">// Permissions:</span>
<span class="c1">//    - the new image at UENVS  -- kernel R, user R</span>
<span class="c1">//    - envs itself -- kernel RW, user NONE</span>
<span class="c1">// LAB 3: Your code here.</span>
<span class="n">boot_map_region</span><span class="p">(</span><span class="n">kern_pgdir</span><span class="p">,</span> <span class="n">UENVS</span><span class="p">,</span> <span class="n">PTSIZE</span><span class="p">,</span> <span class="n">PADDR</span><span class="p">(</span><span class="n">envs</span><span class="p">),</span> <span class="n">PTE_U</span><span class="p">);</span>
</pre></div>


<h3>Exercise 2</h3>
<h4>2.1 env_init()</h4>
<p>在2中已经分配的 envs，env_init() 作用就是对 envs 数组 env_free_list 初始化。为了保证第一次调用 env_alloc() 的时候，能够返回的是 envs[0], 所以注意循环的顺序。</p>
<div class="highlight"><pre><span class="kt">void</span>
<span class="nf">env_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// Set up envs array</span>
  <span class="c1">// LAB 3: Your code here.</span>
  <span class="n">memset</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span> <span class="n">envs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">Env</span><span class="p">)</span> <span class="o">*</span> <span class="n">NENV</span><span class="p">);</span>
  <span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">env_free_list</span> <span class="o">=</span> <span class="n">envs</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span> <span class="p">;</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="n">NENV</span><span class="p">;</span><span class="n">i</span> <span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">envs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">env_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">envs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">env_status</span> <span class="o">=</span> <span class="n">ENV_FREE</span><span class="p">;</span>
    <span class="n">envs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">env_link</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">envs</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
  <span class="p">}</span>

  <span class="n">envs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">env_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">envs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">env_status</span> <span class="o">=</span> <span class="n">ENV_FREE</span><span class="p">;</span>
  <span class="n">envs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">env_link</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

  <span class="c1">// Per-CPU part of the initialization</span>
  <span class="n">env_init_percpu</span><span class="p">();</span> <span class="c1">// 初始化了每个CPU的 GDT，和一些段寄存器的值( gs, fs, es, ds, ss, cs)，同时将 LDT 清零。</span>
<span class="p">}</span>
</pre></div>


<h4>2.2 env_setup_vm()</h4>
<p>对于一个给定的 env ，初始化它的 env_pgdir，也就是虚拟地址空间。在这里注意需要将 kern_pgdir 作为模板初始化 env_pgdir ，这样做的原因是为了能够当在 kernel 态，访问 user 态的一个虚拟地址的时候，只要将页表切换为 user 的页表，同时能够保证 kernel 的代码能够继续执行。注意 kern_pgidr 权限的控制。</p>
<div class="highlight"><pre><span class="k">static</span> <span class="kt">int</span>
<span class="nf">env_setup_vm</span><span class="p">(</span><span class="k">struct</span> <span class="n">Env</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">PageInfo</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">page_alloc</span><span class="p">(</span><span class="n">ALLOC_ZERO</span><span class="p">)))</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">E_NO_MEM</span><span class="p">;</span>

  <span class="n">p</span><span class="o">-&gt;</span><span class="n">pp_ref</span> <span class="o">++</span><span class="p">;</span>
  <span class="n">e</span><span class="o">-&gt;</span><span class="n">env_pgdir</span> <span class="o">=</span> <span class="n">page2kva</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
  <span class="n">memmove</span><span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">env_pgdir</span><span class="p">,</span> <span class="n">kern_pgdir</span><span class="p">,</span> <span class="n">PGSIZE</span><span class="p">);</span>

  <span class="n">e</span><span class="o">-&gt;</span><span class="n">env_pgdir</span><span class="p">[</span><span class="n">PDX</span><span class="p">(</span><span class="n">UVPT</span><span class="p">)]</span> <span class="o">=</span> <span class="n">PADDR</span><span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">env_pgdir</span><span class="p">)</span> <span class="o">|</span> <span class="n">PTE_P</span> <span class="o">|</span> <span class="n">PTE_U</span><span class="p">;</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<h4>2.3 region_alloc()</h4>
<p>在给定的 env 上，分配物理页，映射到给定的虚拟地址上。物理页不用 memset 为0。</p>
<div class="highlight"><pre><span class="k">static</span> <span class="kt">void</span>
<span class="nf">region_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">Env</span> <span class="o">*</span><span class="n">e</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">va</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">va</span> <span class="o">=</span> <span class="n">ROUNDDOWN</span><span class="p">(</span><span class="n">va</span><span class="p">,</span> <span class="n">PGSIZE</span><span class="p">);</span>
  <span class="kt">void</span> <span class="o">*</span> <span class="n">va_end</span><span class="p">;</span>
  <span class="n">va_end</span> <span class="o">=</span> <span class="n">va</span> <span class="o">+</span> <span class="n">ROUNDUP</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">PGSIZE</span><span class="p">);</span>
  <span class="k">struct</span> <span class="n">PageInfo</span> <span class="o">*</span><span class="n">pp</span> <span class="p">;</span>
  <span class="k">for</span><span class="p">(;</span> <span class="n">va</span> <span class="o">&lt;</span> <span class="n">va_end</span> <span class="p">;</span><span class="n">va</span> <span class="o">+=</span> <span class="n">PGSIZE</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">pp</span> <span class="o">=</span> <span class="n">page_alloc</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pp</span><span class="p">)</span> 
      <span class="n">panic</span><span class="p">(</span><span class="s">&quot;region_alloc : page_alloc() out of memory.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">page_insert</span><span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">env_pgdir</span><span class="p">,</span> <span class="n">pp</span><span class="p">,</span> <span class="n">va</span><span class="p">,</span> <span class="n">PTE_U</span> <span class="o">|</span> <span class="n">PTE_W</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> 
      <span class="n">panic</span><span class="p">(</span><span class="s">&quot;region_alloc : page_insert() %e.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
  <span class="p">}</span>

<span class="p">}</span>
</pre></div>


<h4>2.4 load_icode()</h4>
<p>将一个ELF文件 load 到内存中,关于 ELF 文件的格式,可以参考 <strong><a href="http://pdos.csail.mit.edu/6.828/2012/readings/elf.pdf">这里</a></strong>.ELF 文件是有一个elfhdr，里面记录了Proghdr。elfhdr-&gt;e_phnum 表示有多少个Proghdr，最开始的Proghdr 的为值通过 elfhdr-&gt;e_phoff 这个偏移量给出。对于每个 Proghdr，只有 p_type 是 ELF_PROG_LOAD 的表示可以 load 到内存中。同时 Proghdr-&gt;p_memsz 表示占用内存的大小， Proghdr-&gt;p_filesz 表示 在Proghdr的大小，这两个可以不一样，memsz - filesz 就是 BSS 段的大小，所以在初始化的时候，需要将 BSS 段清零。 Proghdr-&gt;p_va 表示这段对应的虚拟地址。 初始化 va 对应的 PTE。</p>
<div class="highlight"><pre><span class="k">static</span> <span class="kt">void</span>
<span class="nf">load_icode</span><span class="p">(</span><span class="k">struct</span> <span class="n">Env</span> <span class="o">*</span><span class="n">e</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">binary</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="n">Proghdr</span> <span class="o">*</span><span class="n">ph</span><span class="p">,</span> <span class="o">*</span><span class="n">eph</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">Elf</span> <span class="o">*</span><span class="n">elfhdr</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">PageInfo</span> <span class="o">*</span><span class="n">pp</span><span class="p">;</span>

  <span class="n">elfhdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">Elf</span> <span class="o">*</span><span class="p">)</span> <span class="n">binary</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">elfhdr</span><span class="o">-&gt;</span><span class="n">e_magic</span> <span class="o">!=</span> <span class="n">ELF_MAGIC</span><span class="p">)</span>
    <span class="n">panic</span><span class="p">(</span><span class="s">&quot;load_icode : not an valid ELF.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

  <span class="n">ph</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">Proghdr</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">binary</span> <span class="o">+</span> <span class="n">elfhdr</span><span class="o">-&gt;</span><span class="n">e_phoff</span><span class="p">);</span>
  <span class="n">eph</span> <span class="o">=</span> <span class="n">ph</span> <span class="o">+</span> <span class="n">elfhdr</span><span class="o">-&gt;</span><span class="n">e_phnum</span><span class="p">;</span>

  <span class="c1">// 因为memmove 操作都需要将一段kernel的内存复制到 user 的一个虚拟地址上</span>
  <span class="c1">// 所以在这里先将页表替换为 user 的页表，就能够访问 user 的虚拟地址了，</span>
  <span class="c1">// 又因为 user 的页表初始化的时候，模版是 kernel 的 kern_pgdir ，包含了</span>
  <span class="c1">// kernel 部分的页表，所以这个时候，kernel 还是可以继续执行的。</span>
  <span class="n">lcr3</span><span class="p">(</span><span class="n">PADDR</span><span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">env_pgdir</span><span class="p">));</span>

  <span class="k">for</span> <span class="p">(;</span> <span class="n">ph</span> <span class="o">&lt;</span> <span class="n">eph</span><span class="p">;</span> <span class="n">ph</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ph</span><span class="o">-&gt;</span><span class="n">p_type</span> <span class="o">!=</span> <span class="n">ELF_PROG_LOAD</span><span class="p">)</span>
      <span class="k">continue</span><span class="p">;</span>
    <span class="n">region_alloc</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">ph</span><span class="o">-&gt;</span><span class="n">p_va</span><span class="p">,</span> <span class="n">ph</span><span class="o">-&gt;</span><span class="n">p_memsz</span><span class="p">);</span>
    <span class="n">memset</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">ROUNDDOWN</span><span class="p">((</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">ph</span><span class="o">-&gt;</span><span class="n">p_va</span><span class="p">,</span> <span class="n">PGSIZE</span><span class="p">),</span> <span class="mi">0</span> <span class="p">,</span>
           <span class="n">ROUNDUP</span><span class="p">(</span><span class="n">ph</span><span class="o">-&gt;</span><span class="n">p_memsz</span><span class="p">,</span> <span class="n">PGSIZE</span><span class="p">));</span>
    <span class="n">memmove</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">ph</span><span class="o">-&gt;</span><span class="n">p_va</span><span class="p">,</span> <span class="n">binary</span><span class="o">+</span><span class="n">ph</span><span class="o">-&gt;</span><span class="n">p_offset</span><span class="p">,</span> <span class="n">ph</span><span class="o">-&gt;</span><span class="n">p_filesz</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// e_entry 程序段的入口地址。</span>
  <span class="n">e</span><span class="o">-&gt;</span><span class="n">env_tf</span><span class="p">.</span><span class="n">tf_eip</span> <span class="o">=</span> <span class="n">elfhdr</span><span class="o">-&gt;</span><span class="n">e_entry</span><span class="p">;</span>

  <span class="c1">// 初始化 user 的 栈。</span>
  <span class="n">region_alloc</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)(</span><span class="n">USTACKTOP</span><span class="o">-</span><span class="n">PGSIZE</span><span class="p">),</span> <span class="n">PGSIZE</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<h4>2.5 env_create()</h4>
<p>通过 env_alloc 从 env_free_list 上分配 env 所需要的空间，初始化其中的一些状态信息（除了 env_pgdir 之外的信息）。调用 load_icode 将 ELF load 到对应的虚拟地址空间上。同时初始化对应的PTE。</p>
<div class="highlight"><pre><span class="kt">void</span>
<span class="nf">env_create</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">binary</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="k">enum</span> <span class="n">EnvType</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// LAB 3: Your code here.</span>
  <span class="k">struct</span> <span class="n">Env</span> <span class="o">*</span><span class="n">newenv</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
  <span class="k">if</span><span class="p">((</span><span class="n">r</span> <span class="o">=</span> <span class="n">env_alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newenv</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span>
    <span class="n">panic</span><span class="p">(</span><span class="s">&quot;env_create : env_alloc %e.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>

  <span class="n">load_icode</span><span class="p">(</span><span class="n">newenv</span><span class="p">,</span> <span class="n">binary</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
  <span class="n">newenv</span><span class="o">-&gt;</span><span class="n">env_type</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<h4>2.6 env_run()</h4>
<p>更新 curenv，因为在第一个 env run 之前， curenv 为 NULL，需要加上判断 NULL 的情况。然后替换页表，替换各种寄存器，让新的env从上次中断的地方继续执行，调用 env_pop_tf 之后，就不会再返回，直接执行 env 的程序。</p>
<div class="highlight"><pre><span class="kt">void</span>
<span class="nf">env_run</span><span class="p">(</span><span class="k">struct</span> <span class="n">Env</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// Step 1</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">curenv</span> <span class="o">&amp;&amp;</span> <span class="n">curenv</span><span class="o">-&gt;</span><span class="n">env_status</span> <span class="o">==</span> <span class="n">ENV_RUNNING</span><span class="p">)</span> 
    <span class="n">curenv</span><span class="o">-&gt;</span><span class="n">env_status</span> <span class="o">=</span> <span class="n">ENV_RUNNABLE</span><span class="p">;</span>
  <span class="n">curenv</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">curenv</span><span class="o">-&gt;</span><span class="n">env_status</span> <span class="o">==</span> <span class="n">ENV_RUNNABLE</span><span class="p">);</span>
  <span class="n">curenv</span><span class="o">-&gt;</span><span class="n">env_status</span> <span class="o">=</span> <span class="n">ENV_RUNNING</span><span class="p">;</span>
  <span class="n">curenv</span><span class="o">-&gt;</span><span class="n">env_runs</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">lcr3</span><span class="p">(</span><span class="n">PADDR</span><span class="p">(</span><span class="n">curenv</span><span class="o">-&gt;</span><span class="n">env_pgdir</span><span class="p">));</span>

  <span class="c1">// Step 2</span>
  <span class="n">env_pop_tf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">curenv</span><span class="o">-&gt;</span><span class="n">env_tf</span><span class="p">);</span>
  <span class="n">panic</span><span class="p">(</span><span class="s">&quot;env_run not yet implemented&quot;</span><span class="p">);</span><span class="c1">// should be never executed</span>
<span class="p">}</span>
</pre></div>


<p>env_pop_tf ： 用 tf 的地址赋值给esp，从trapframe上恢复 struct PushRegs 和 ES， DS。然后跳过trapno 和 errcode，然后对于这个trap 是否又 特权等级的变化，IRET 指令能够处理（参考Intel Instruction Set Reference A-M 中的IRET指令的说明)。简而言之就是，iret 会从栈上pop出 eip 和 cs，然后从这个地方开始执行。</p>
<div class="highlight"><pre><span class="kt">void</span>
<span class="nf">env_pop_tf</span><span class="p">(</span><span class="k">struct</span> <span class="n">Trapframe</span> <span class="o">*</span><span class="n">tf</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kr">__asm</span> <span class="n">__volatile</span><span class="p">(</span><span class="s">&quot;movl %0,%%esp</span><span class="se">\n</span><span class="s">&quot;</span>
    <span class="s">&quot;</span><span class="se">\t</span><span class="s">popal</span><span class="se">\n</span><span class="s">&quot;</span>
    <span class="s">&quot;</span><span class="se">\t</span><span class="s">popl %%es</span><span class="se">\n</span><span class="s">&quot;</span>
    <span class="s">&quot;</span><span class="se">\t</span><span class="s">popl %%ds</span><span class="se">\n</span><span class="s">&quot;</span>
    <span class="s">&quot;</span><span class="se">\t</span><span class="s">addl $0x8,%%esp</span><span class="se">\n</span><span class="s">&quot;</span> <span class="cm">/* skip tf_trapno and tf_errcode */</span>
    <span class="s">&quot;</span><span class="se">\t</span><span class="s">iret&quot;</span>
    <span class="o">:</span> <span class="o">:</span> <span class="s">&quot;g&quot;</span> <span class="p">(</span><span class="n">tf</span><span class="p">)</span> <span class="o">:</span> <span class="s">&quot;memory&quot;</span><span class="p">);</span>
  <span class="n">panic</span><span class="p">(</span><span class="s">&quot;iret failed&quot;</span><span class="p">);</span>  <span class="cm">/* mostly to placate the compiler */</span>
<span class="p">}</span>
</pre></div>


<h3>Exercise 4</h3>
<h4>4.1 初始化 IDT</h4>
<p>在 trapentry.S 中初始化中断处理函数，根据是否有Error Code，中断处理函数分为两种 TRAPHANDLER_NOEC 和 TRAPHANDLER。看代码发现其本质就是 初始化 trapframe 中的 tf_trapno 和 tf_err 字段，然后，跳到 _alltraps 统一处理。</p>
<div class="highlight"><pre><span class="cp">#define TRAPHANDLER(name, num)            \</span>
<span class="cp">  .globl name;    </span><span class="cm">/* define global symbol for &#39;name&#39; */</span><span class="cp"> \</span>
<span class="cp">  .type name, @function;  </span><span class="cm">/* symbol type is function */</span><span class="cp">   \</span>
<span class="cp">  .align 2;   </span><span class="cm">/* align function definition */</span><span class="cp">   \</span>
<span class="cp">  name:     </span><span class="cm">/* function starts here */</span><span class="cp">    \</span>
<span class="cp">  pushl $(num);             \</span>
<span class="cp">  jmp _alltraps</span>

<span class="cp">#define TRAPHANDLER_NOEC(name, num)         \</span>
<span class="cp">  .globl name;              \</span>
<span class="cp">  .type name, @function;            \</span>
<span class="cp">  .align 2;             \</span>
<span class="cp">  name:               \</span>
<span class="cp">  pushl $0;             \</span>
<span class="cp">  pushl $(num);             \</span>
<span class="cp">  jmp _alltraps</span>
</pre></div>


<p>所以中断处理函数 通过查 Intel 的 中断那节的 Manual 可以这样：</p>
<div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Lab 3: Your code here for generating entry points for the different traps.</span>
<span class="cm"> */</span>
<span class="c1">// check if has error code : http://pdos.csail.mit.edu/6.828/2012/readings/i386/s09_06.htm</span>
<span class="c1">// or http://pdos.csail.mit.edu/6.828/2012/readings/ia32/IA32-3A.pdf Chapter 5,</span>
<span class="c1">// table 5-1</span>
<span class="n">TRAPHANDLER_NOEC</span><span class="p">(</span><span class="n">idt_divide</span><span class="p">,</span> <span class="n">T_DIVIDE</span><span class="p">)</span> 
<span class="n">TRAPHANDLER_NOEC</span><span class="p">(</span><span class="n">idt_debug</span><span class="p">,</span> <span class="n">T_DEBUG</span><span class="p">)</span> 
<span class="p">...</span> 
<span class="n">TRAPHANDLER_NOEC</span><span class="p">(</span><span class="n">idt_irq_ide</span><span class="p">,</span> <span class="n">IRQ_OFFSET</span> <span class="o">+</span> <span class="n">IRQ_IDE</span><span class="p">)</span>
<span class="n">TRAPHANDLER_NOEC</span><span class="p">(</span><span class="n">idt_irq_error</span><span class="p">,</span> <span class="n">IRQ_OFFSET</span> <span class="o">+</span> <span class="n">IRQ_ERROR</span><span class="p">)</span>
</pre></div>


<p>对于 _alltraps 函数，因为 trapframe 的 eip , cs 及后面的字段都是硬件保存了，所以我们只要保存PushRegs 和 ds es 就可以。</p>
<div class="highlight"><pre><span class="p">.</span><span class="n">global</span> <span class="n">_alltraps</span>
<span class="nl">_alltraps</span> <span class="p">:</span>
  <span class="c1">// Build trap frame as an argument of trap(struct Trapframe *tf)</span>
  <span class="c1">// in trap.c , trapno and error code are set up by TRAPHANDLER</span>
  <span class="c1">// and TRAPHANDLER_NOEC</span>
  <span class="n">pushl</span> <span class="o">%</span><span class="n">ds</span>
  <span class="n">pushl</span> <span class="o">%</span><span class="n">es</span>
  <span class="n">pushal</span>

  <span class="c1">// Set up data and per-cpu segment , cs and ss are set up by h/w</span>
  <span class="n">movw</span> <span class="err">$</span><span class="p">(</span><span class="n">GD_KD</span><span class="p">),</span> <span class="o">%</span><span class="n">ax</span>
  <span class="n">movw</span> <span class="o">%</span><span class="n">ax</span><span class="p">,</span> <span class="o">%</span><span class="n">ds</span>
  <span class="n">movw</span> <span class="o">%</span><span class="n">ax</span><span class="p">,</span> <span class="o">%</span><span class="n">es</span>
  <span class="n">movw</span> <span class="o">%</span><span class="n">ax</span><span class="p">,</span> <span class="o">%</span><span class="n">fs</span>
  <span class="n">movw</span> <span class="o">%</span><span class="n">ax</span><span class="p">,</span> <span class="o">%</span><span class="n">gs</span>

  <span class="c1">// Call trap(struct Trapframe *tr)</span>
  <span class="n">pushl</span> <span class="o">%</span><span class="n">esp</span>
  <span class="n">call</span> <span class="n">trap</span>
  <span class="n">addl</span> <span class="err">$</span><span class="mi">4</span><span class="p">,</span> <span class="o">%</span><span class="n">esp</span>
</pre></div>


<p>初始化 IDT </p>
<div class="highlight"><pre><span class="kt">void</span>
<span class="nf">trap_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">extern</span> <span class="k">struct</span> <span class="n">Segdesc</span> <span class="n">gdt</span><span class="p">[];</span>

  <span class="c1">// LAB 3: Your code here.</span>
  <span class="c1">// set up idt</span>
  <span class="k">extern</span> <span class="kt">void</span> <span class="n">idt_divide</span><span class="p">();</span>
  <span class="k">extern</span> <span class="kt">void</span> <span class="n">idt_debug</span><span class="p">();</span>
  <span class="p">....</span> 
  <span class="k">extern</span> <span class="kt">void</span> <span class="n">idt_irq_ide</span><span class="p">();</span>
  <span class="k">extern</span> <span class="kt">void</span> <span class="n">idt_irq_error</span><span class="p">();</span>


  <span class="kt">int</span> <span class="n">i</span> <span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">256</span> <span class="p">;</span><span class="n">i</span> <span class="o">++</span><span class="p">)</span>
    <span class="n">SETGATE</span><span class="p">(</span><span class="n">idt</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GD_KT</span><span class="p">,</span> <span class="n">idt_default</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

  <span class="n">SETGATE</span><span class="p">(</span><span class="n">idt</span><span class="p">[</span><span class="n">T_DIVIDE</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">GD_KT</span><span class="p">,</span> <span class="n">idt_divide</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">SETGATE</span><span class="p">(</span><span class="n">idt</span><span class="p">[</span><span class="n">T_DEBUG</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">GD_KT</span><span class="p">,</span> <span class="n">idt_debug</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="p">...</span> 
  <span class="n">SETGATE</span><span class="p">(</span><span class="n">idt</span><span class="p">[</span><span class="n">IRQ_OFFSET</span> <span class="o">+</span> <span class="n">IRQ_IDE</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GD_KT</span><span class="p">,</span> <span class="n">idt_irq_ide</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">SETGATE</span><span class="p">(</span><span class="n">idt</span><span class="p">[</span><span class="n">IRQ_OFFSET</span> <span class="o">+</span> <span class="n">IRQ_ERROR</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GD_KT</span><span class="p">,</span> <span class="n">idt_irq_error</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

  <span class="c1">// Per-CPU setup </span>
  <span class="n">trap_init_percpu</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>


<h4>4.2 Question 1</h4>
<p>不能知道是否含有 Error Code，不能够通过硬件屏蔽某个中断。</p>
<h4>4.3 Question 2</h4>
<p>softint 虽然 int $14，但是 14 这个中断的 DPL = 0， 所以 user 没有这个权限访问这个段，就产生了 13 中断。如果 kernel 允许user直接产生 pagefault，主要看kernel怎么处理 user 产生的 pagefault 了，如果监测到 user 在访问一个不能够访问的地址，产生PF，另外user是没有权限写 CR2 寄存器的，但是CR2寄存器里面可能有值，kernel如果处理不当，会导致user得到这个地址的访问权限。</p>
<p>-- EOF --</p>
            </div>
            <!-- /.entry-content -->
        </article>
    </section>

        </div>
    </div>
</div>
<footer>
   <div class="container">
      <hr>
      <div class="row">
         <div class="col-xs-10">&copy; 2013 zorksylar
            &middot; Powered by <a href="https://github.com/DandyDev/pelican-bootstrap3" target="_blank">pelican-bootstrap3</a>,
            <a href="http://docs.getpelican.com/" target="_blank">Pelican</a>,
            <a href="http://getbootstrap.com" target="_blank">Bootstrap</a>         </div>
         <div class="col-xs-2"><p class="pull-right"><i class="fa fa-arrow-up"></i> <a href="#">Back to top</a></p></div>
      </div>
   </div>
</footer>
<script src="http://zorksylar.github.io/theme/js/jquery.min.js"></script>

<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="http://zorksylar.github.io/theme/js/bootstrap.min.js"></script>

<!-- Enable responsive features in IE8 with Respond.js (https://github.com/scottjehl/Respond) -->
<script src="http://zorksylar.github.io/theme/js/respond.min.js"></script>


</body>
</html>