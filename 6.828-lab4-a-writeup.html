<!DOCTYPE html>
<html lang="en" prefix="og: http://ogp.me/ns# fb: https://www.facebook.com/2008/fbml">
<head>
    <title>6.828 Lab4 PartA 小结 - Z's Thoughts</title>
    <!-- Using the latest rendering mode for IE -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">



<link rel="canonical" href="http://zorksylar.github.io/6.828-lab4-a-writeup.html">

        <meta name="author" content="zorksylar" />
        <meta name="keywords" content="[6.828,OS]" />
        <meta name="description" content="Multiprocessor Support and Cooperative Multitasking" />

        <meta property="og:site_name" content="Z's Thoughts" />
        <meta property="og:type" content="article"/>
        <meta property="og:title" content="6.828 Lab4 PartA 小结"/>
        <meta property="og:url" content="http://zorksylar.github.io/6.828-lab4-a-writeup.html"/>
        <meta property="og:description" content="Multiprocessor Support and Cooperative Multitasking"/>
        <meta property="article:published_time" content="2013-08-22" />
            <meta property="article:section" content="Blog" />
            <meta property="article:tag" content="[6.828" />
            <meta property="article:tag" content="OS]" />
            <meta property="article:author" content="zorksylar" />



    <!-- Bootstrap -->
        <link rel="stylesheet" href="http://zorksylar.github.io/theme/css/bootstrap.min.css" type="text/css"/>
    <link href="http://zorksylar.github.io/theme/css/font-awesome.min.css" rel="stylesheet">

    <link href="http://zorksylar.github.io/theme/css/pygments/manni.css" rel="stylesheet">
    <link rel="stylesheet" href="http://zorksylar.github.io/theme/css/style.css" type="text/css"/>

        <link href="http://zorksylar.github.io/feeds/all.atom.xml" type="application/atom+xml" rel="alternate"
              title="Z's Thoughts ATOM Feed"/>



        <link href="http://zorksylar.github.io/feeds/blog.atom.xml" type="application/atom+xml" rel="alternate"
              title="Z's Thoughts Blog ATOM Feed"/>

</head>
<body>

<div class="navbar navbar-default navbar-fixed-top" role="navigation">
	<div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a href="http://zorksylar.github.io/" class="navbar-brand">
Z's Thoughts            </a>
        </div>
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav">
                        <li class="active">
                            <a href="http://zorksylar.github.io/category/blog.html">Blog</a>
                        </li>
            </ul>
            <ul class="nav navbar-nav navbar-right">
              <li><a href="http://zorksylar.github.io/archives.html"><i class="fa fa-th-list"></i><span class="icon-label">Archives</span></a></li>
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
</div> <!-- /.navbar -->
<!-- Banner -->
<!-- End Banner -->
<div class="container">
    <div class="row">
        <div class="col-lg-12">
    <section id="content">
        <article>
            <header class="page-header">
                <h1>
                    <a href="http://zorksylar.github.io/6.828-lab4-a-writeup.html"
                       rel="bookmark"
                       title="Permalink to 6.828 Lab4 PartA 小结">
                        6.828 Lab4 PartA 小结
                    </a>
                </h1>
            </header>
            <div class="entry-content">
                <div class="panel">
                    <div class="panel-body">
<footer class="post-info">
    <span class="label label-default">Date</span>
    <span class="published">
        <i class="fa fa-calendar"></i><time datetime="2013-08-22T00:00:00+08:00"> Thu 22 August 2013</time>
    </span>





<span class="label label-default">Tags</span>
	<a href="http://zorksylar.github.io/tag/6828.html">[6.828</a>
        /
	<a href="http://zorksylar.github.io/tag/os.html">OS]</a>
    
</footer><!-- /.post-info -->                    </div>
                </div>
                <h3>Multiprocessor Support and Cooperative Multitasking</h3>
<p>In this secion we will introduce the following concepts : <code>mmio</code>, <code>vma</code>, <code>lma</code>, <code>elf</code>, and <code>apic</code>.</p>
<h3>PartA部分说明</h3>
<p>前面的几个Lab只能支持单核，Lab4的PartA就是在之前的基础上，加上多核的扩展。主要工作是两方面 ：
<em> 多核怎么boot，怎么初始化多核的数据结构。
</em> 对于多核共享的数据结构，怎么处理data race。</p>
<h3>Exercise 1</h3>
<h4>Something need to know</h4>
<p>在JOS中，支持的是SMP（symmetric multiprocessing）：多个核在访问内存和IO和其他系统资源都是相互平等的关系，所有的CPU可以认为是一样的。</p>
<p>在boot阶段，CPU被分为两类：
<em> the bootstrap processor (BSP) : 负责初始化整个系统和操作系统的一些基本的数据结构（如 pages 等等）。
</em> the application processors (APs)：当JOS Boot起来之后，由BSP 发送STARTUP 指令，将其他CPU 激活。</p>
<p>在SMP系统中，每个CPU都有一个本地的APIC单元（Advanced Programmable Interrupt Controller），这个单元有两个作用：
<em> 负责在整个系统中控制和传递中断。
</em> 区别各个CPU。LAPIC提供给和它相连的CPU一个唯一的ID号，通过读APIC的 ID 就能够知道当前是哪个CPU在运行。</p>
<p>一个CPU通过MMIO访问对应的LAPIC。MMIO (Memory Mapped IO) : 将物理地址映射到一些IO设备的寄存器，这样通过对这些个物理地址的load/store操作，就相当于对这些寄存器进行了访问。(在之前的Lab里面，page_init()的时候，留出了IO hole，就是为了这里MMIO)。</p>
<h4>Exercise 1</h4>
<p>为 APIC 需要MMIO访问的地址分配空间。给出MMIO 的 pa 和 len，返回访问这个 pa 的 va。通过boot_map_region函数实现。注意对齐和检测地址溢出。因为这块内存不是普通的内存，所以安全起见，需要对这块内存不做缓存处理，所以PTE_PCD | PTE_PWT | PTE_W。 PTE_PCD 表示 page cache disabled, PTE_PWT 表示 page write through.</p>
<div class="highlight"><pre><span class="kt">void</span> <span class="o">*</span>
<span class="nf">mmio_map_region</span><span class="p">(</span><span class="kt">physaddr_t</span> <span class="n">pa</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">void</span> <span class="o">*</span> <span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">base</span><span class="p">;</span>
  <span class="n">size</span> <span class="o">=</span> <span class="n">ROUNDUP</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">PGSIZE</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">base</span> <span class="o">+</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="n">MMIOLIM</span> <span class="o">||</span> <span class="n">base</span> <span class="o">+</span> <span class="n">size</span> <span class="o">&lt;</span> <span class="n">base</span> <span class="p">)</span>
    <span class="n">panic</span><span class="p">(</span><span class="s">&quot;mmio_map_region : reservation overflow.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="n">boot_map_region</span><span class="p">(</span><span class="n">kern_pgdir</span> <span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">pa</span><span class="p">,</span> <span class="n">PTE_PCD</span> <span class="o">|</span> <span class="n">PTE_PWT</span> <span class="o">|</span> <span class="n">PTE_W</span><span class="p">);</span>
  <span class="n">base</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<h3>Exercise 2</h3>
<h4>Something need to know</h4>
<p>在BSP boot 之后， APs boot的简单过程：</p>
<ol>
<li>读取多核的配置信息。在BIOS 中存储着这个多核系统的基本信息，诸如：CPU的个数，对应的APIC的ID，和每个APIC对应的MMIO的地址。第一步要做的就是读取这些信息，通过kernel/mpconfig.c 中的mp_init()</li>
<li>BPS初始化自己的APIC，根据BIOS中的配置信息，初始化自己APIC对应的MMIO(通过调用mmio_map_region) 和其他APIC的信息。lapic_init()</li>
<li>BPS初始化对应的中断控制器。 pic_init()</li>
<li>boot CPU。和单个CPU的boot稍微有区别。初始化每个CPU的栈(当前使用的栈还是，同时将一段汇编代码mpentry.S装载到物理地址为MPENTRY_ADDR的内存中，lapic发送 START 指令，让每个CPU开始执行这段代码。 mpentry.S的作用就是把CPU boot起来，初始化页表，打开paging，把栈从临时boot的栈切换到最开始初始化的栈(KSTACKTOP下面区域)上。</li>
<li>在mpentry.S的最后，跳到mp_main()执行，做以下操作：<ol>
<li>切换页表到kern_pgdir.</li>
<li>初始化APs自己的APIC，lapic_init()</li>
<li>初始化APs自己的GDT 和 Segment Descriptor( ES, DS, SS, FS, GS, CS) env_init_percpu()</li>
<li>初始化APs自己的TSS 和 IDT trap_init_percpu() </li>
<li>更新CPU的状态信息</li>
</ol>
</li>
</ol>
<p>这个时候 APs 算是 boot 完成了。</p>
<h4>Exercise 2</h4>
<p>因为在boot APs的时候，需要将mpentry.S load到 MPENTRY_ADDR中，所以在page_init()的时候，需要把MPENTRY_ADDR 标记为占用。</p>
<div class="highlight"><pre><span class="k">for</span> <span class="p">(</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PGNUM</span><span class="p">(</span><span class="n">IOPHYSMEM</span><span class="p">);</span> <span class="n">i</span> <span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// LAB 4 mark the physical page at MPENTRY_PADDR as in use.</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">i</span> <span class="o">==</span> <span class="n">PGNUM</span><span class="p">(</span><span class="n">MPENTRY_PADDR</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pp_ref</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pp_link</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pp_ref</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pp_link</span> <span class="o">=</span> <span class="n">page_free_list</span><span class="p">;</span>
    <span class="n">page_free_list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<h4>Qestion 1</h4>
<p>MPBOOTPHYS的作用就是将VA(Virtual Address)转化为PA(Physical Address)，在boot/boot.S中，将ELF文件load到内存中，同时开始执行kern/entry.S的代码，entry.S的作用就load 临时的页表(kern/entry_pgdir， [0,4MB])，打开分页。
然而在boot APs的时候就不能这么做了，因为Intel 的 Multiprocessor Specificatoin B4.2 对 APIC 的 STARTUP 指令说明如下：</p>
<blockquote>
<p>The STARTUP IPI causes the target processor to start executing in Real Mode from address 000VV000h, where VV is an 8-bit vector that is part of the IPI message. Startup vectors are limited to a 4-kilobyte page boundary in the first megabyte of the address space. Vectors A0-BF are reserved; do not use vectors in this range.</p>
</blockquote>
<p>就是说在STARTUP 之后，运行在实模式下，只能用CS：IP寻址，并且CS：IP被限制在XY00:0000 (XY 为 8 bit)内，只能在4K范围内，所以boot_aps()把mpentry.S 复制到了MPENTRY_PADDR(0x7000)这个地址物理上，为了能够将虚拟地址转化到MPENTRY_PADDR起始的物理地址上，就需要MPBOOTPHYS这个宏。</p>
<p>另外关于 VMA 和 LMA的区别，GNU官方这样说的:</p>
<blockquote>
<p>Every loadable or allocatable output section has two addresses. The first is the VMA, or virtual memory address. This is the address the section will have when the output file is run. The second is the LMA, or load memory address. This is the address at which the section will be loaded. In most cases the two addresses will be the same. An example of when they might be different is when a data section is loaded into ROM, and then copied into RAM when the program starts up (this technique is often used to initialize global variables in a ROM based system). In this case the ROM address would be the LMA, and the RAM address would be the VMA. </p>
</blockquote>
<h3>Exercise 3, 4</h3>
<h4>Something need to know</h4>
<p>对于多核操作系统，需要注意对于每个CPU，哪些数据结构是私有的，哪些是共享的。在JOS中，对每个CPU都有struct CpuInfo:</p>
<div class="highlight"><pre><span class="c1">// Per-CPU state</span>
<span class="k">struct</span> <span class="n">CpuInfo</span> <span class="p">{</span>
  <span class="kt">uint8_t</span> <span class="n">cpu_id</span><span class="p">;</span>                 <span class="c1">// Local APIC ID; index into cpus[] below</span>
  <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="n">cpu_status</span><span class="p">;</span>   <span class="c1">// The status of the CPU</span>
  <span class="k">struct</span> <span class="n">Env</span> <span class="o">*</span><span class="n">cpu_env</span><span class="p">;</span>            <span class="c1">// The currently-running environment.</span>
  <span class="k">struct</span> <span class="n">Taskstate</span> <span class="n">cpu_ts</span><span class="p">;</span>        <span class="c1">// Used by x86 to find stack for interrupt</span>
<span class="p">};</span>
</pre></div>


<ol>
<li>栈. percpu_kstacks[NCPU][KSTKSIZE]</li>
<li>TSS 和 TSS 描述符</li>
<li>当前运行的env</li>
<li>寄存器上下文</li>
</ol>
<h4>Exercise 3</h4>
<p>在BSP mem_init()的时候对所有CPU初始化栈的页表:</p>
<div class="highlight"><pre><span class="k">static</span> <span class="kt">void</span>
<span class="nf">mem_init_mp</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">uint32_t</span> <span class="n">kstacktop_i</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span> <span class="p">;</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">NCPU</span> <span class="p">;</span><span class="n">i</span> <span class="o">++</span><span class="p">){</span>
    <span class="n">kstacktop_i</span> <span class="o">=</span> <span class="n">KSTACKTOP</span> <span class="o">-</span> <span class="n">i</span> <span class="o">*</span> <span class="p">(</span><span class="n">KSTKSIZE</span> <span class="o">+</span> <span class="n">KSTKGAP</span><span class="p">);</span>
    <span class="n">boot_map_region</span><span class="p">(</span><span class="n">kern_pgdir</span><span class="p">,</span> <span class="n">kstacktop_i</span> <span class="o">-</span> <span class="n">KSTKSIZE</span><span class="p">,</span> <span class="n">KSTKSIZE</span><span class="p">,</span> 
                    <span class="n">PADDR</span><span class="p">(</span><span class="o">&amp;</span><span class="n">percpu_kstacks</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">PTE_W</span><span class="p">);</span>
  <span class="p">}</span>

<span class="p">}</span>
</pre></div>


<h4>Exercise 4</h4>
<p>在BSP 和 APs trap_init()的时候，初始化每个CPU的TSS和IDT</p>
<div class="highlight"><pre><span class="kt">void</span>
<span class="nf">trap_init_percpu</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">thiscpu</span><span class="o">-&gt;</span><span class="n">cpu_ts</span><span class="p">.</span><span class="n">ts_esp0</span> <span class="o">=</span> <span class="n">KSTACKTOP</span> <span class="o">-</span> <span class="p">(</span><span class="n">thiscpu</span><span class="o">-&gt;</span><span class="n">cpu_id</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">KSTKSIZE</span> <span class="o">+</span> <span class="n">KSTKGAP</span><span class="p">);</span>
  <span class="n">thiscpu</span><span class="o">-&gt;</span><span class="n">cpu_ts</span><span class="p">.</span><span class="n">ts_ss0</span> <span class="o">=</span> <span class="n">GD_KD</span><span class="p">;</span>

  <span class="c1">// Initialize the TSS slot of the gdt.</span>
  <span class="n">gdt</span><span class="p">[(</span><span class="n">GD_TSS0</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="n">thiscpu</span><span class="o">-&gt;</span><span class="n">cpu_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">SEG16</span><span class="p">(</span><span class="n">STS_T32A</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">thiscpu</span><span class="o">-&gt;</span><span class="n">cpu_ts</span><span class="p">),</span>
          <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">Taskstate</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">gdt</span><span class="p">[(</span><span class="n">GD_TSS0</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="n">thiscpu</span><span class="o">-&gt;</span><span class="n">cpu_id</span><span class="p">].</span><span class="n">sd_s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="c1">// Load the TSS selector (like other segment selectors, the</span>
  <span class="c1">// bottom three bits are special; we leave them 0)</span>
  <span class="n">ltr</span><span class="p">(</span><span class="n">GD_TSS0</span>  <span class="o">+</span> <span class="p">(</span><span class="n">thiscpu</span><span class="o">-&gt;</span><span class="n">cpu_id</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="p">);</span>

  <span class="c1">// Load the IDT</span>
  <span class="n">lidt</span><span class="p">(</span><span class="o">&amp;</span><span class="n">idt_pd</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<h3>Exercise 5</h3>
<h4>Something need to know</h4>
<p>多核中，时刻要记住，<strong>一行代码都是分成很多小的指令执行的，每个指令执行的时候，都可以被中断掉，并且每行代码都可能被多个CPU同时执行。</strong></p>
<p>为了解决多个CPU访问同一段程序的时候的 race condition，JOS中使用了内核大锁(big kernel lock),其作用就是只能又一个env在kernel态运行，在任何时间，都只能又一个user 的 env 在kernel 执行，这样就防止出现多个CPU同时修改一个env的信息的情况了。所以在从user 进入kernel的时候和kernel跳到user的时候，需要lock_kernel和unlock_kernel。</p>
<p>Big kernel lock 采用的是spinlock，当要尝试获取锁的时候，如果没有拿到就spin在那里，直到拿到为止。</p>
<div class="highlight"><pre><span class="n">truct</span> <span class="n">spinlock</span> <span class="p">{</span>
  <span class="kt">unsigned</span> <span class="n">locked</span><span class="p">;</span>       <span class="c1">// Is the lock held?</span>

<span class="cp">#ifdef DEBUG_SPINLOCK</span>
  <span class="c1">// For debugging:</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>            <span class="c1">// Name of lock.</span>
  <span class="k">struct</span> <span class="n">CpuInfo</span> <span class="o">*</span><span class="n">cpu</span><span class="p">;</span>   <span class="c1">// The CPU holding the lock.</span>
  <span class="kt">uintptr_t</span> <span class="n">pcs</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>     <span class="c1">// The call stack (an array of program counters)</span>
                         <span class="c1">// that locked the lock.</span>
<span class="cp">#endif</span>
<span class="p">};</span>
</pre></div>


<p>在spin_lock的时候，采用了xchg ,xchg能够保证:
<em> 执行是原子的不可在划分的，在执行的时候是不可被中断掉的
</em> 执行是顺序的，不会被乱序优化执行。（有些处理器为了提高执行效率，一段指令可能会被乱序执行，</p>
<p>比如x86 xchg %eax, addr 指令，本质上是:</p>
<ol>
<li>freeze other CPUs' memory activity for address addr</li>
<li>temp := *addr</li>
<li>*addr := %eax</li>
<li>%eax = temp</li>
<li>un-freeze other memory activity</li>
</ol>
<div class="highlight"><pre><span class="kt">void</span>
<span class="nf">spin_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">spinlock</span> <span class="o">*</span><span class="n">lk</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef DEBUG_SPINLOCK</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">holding</span><span class="p">(</span><span class="n">lk</span><span class="p">))</span>
    <span class="n">panic</span><span class="p">(</span><span class="s">&quot;CPU %d cannot acquire %s: already holding&quot;</span><span class="p">,</span> <span class="n">cpunum</span><span class="p">(),</span> <span class="n">lk</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
<span class="cp">#endif</span>

  <span class="c1">// The xchg is atomic.</span>
  <span class="c1">// It also serializes, so that reads after acquire are not</span>
  <span class="c1">// reordered before it. </span>
  <span class="k">while</span> <span class="p">(</span><span class="n">xchg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lk</span><span class="o">-&gt;</span><span class="n">locked</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">asm</span> <span class="k">volatile</span> <span class="p">(</span><span class="s">&quot;pause&quot;</span><span class="p">);</span>

  <span class="c1">// Record info about lock acquisition for debugging.</span>
<span class="cp">#ifdef DEBUG_SPINLOCK</span>
  <span class="n">lk</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">=</span> <span class="n">thiscpu</span><span class="p">;</span>
  <span class="n">get_caller_pcs</span><span class="p">(</span><span class="n">lk</span><span class="o">-&gt;</span><span class="n">pcs</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">uint32_t</span>
<span class="nf">xchg</span><span class="p">(</span><span class="k">volatile</span> <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">newval</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">uint32_t</span> <span class="n">result</span><span class="p">;</span>

  <span class="c1">// The + in &quot;+m&quot; denotes a read-modify-write operand.</span>
  <span class="n">asm</span> <span class="k">volatile</span><span class="p">(</span><span class="s">&quot;lock; xchgl %0, %1&quot;</span> <span class="o">:</span>
      <span class="s">&quot;+m&quot;</span> <span class="p">(</span><span class="o">*</span><span class="n">addr</span><span class="p">),</span> <span class="s">&quot;=a&quot;</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">:</span>
      <span class="s">&quot;1&quot;</span> <span class="p">(</span><span class="n">newval</span><span class="p">)</span> <span class="o">:</span>
      <span class="s">&quot;cc&quot;</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>lock按照提示添加就可以了，基本上都是在user 和 kernel的交界区。
<em> env_run : 从kernel到user，unlock
</em> trap : 从user到kernel, lock
<em> shed_yield : 调用env_run, lock，防止两个CPU同时跑一个env
</em> boot_aps : 在APs boot之前，lock住kernel</p>
<h4>Question 2</h4>
<p>如果是share 一个栈，那么每个CPU的栈相当于是穿插在这个share的栈上，CPU1 push，接着CPU2 push，再CPU1 pop的时候，就会出问题。</p>
<h3>Exercise 6</h3>
<h4>Exercise 6</h4>
<p>实现一个Round-Robin的调度算法，sched_yield() 函数的作用就是从envs中轮询挑选一个空闲的env来执行，如果没有，那么就继续执行之前的那个env，注意不能让两个CPU同时跑一个env。注意，轮询的时候，要从上次sched 的env的位置开始往下找，而不是从头，否则会有一些env始终无法调度到的情况。</p>
<div class="highlight"><pre><span class="kt">void</span>
<span class="nf">sched_yield</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="n">Env</span> <span class="o">*</span><span class="n">idle</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">nxt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">idle</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">curenv</span><span class="p">)</span> 
    <span class="n">nxt</span> <span class="o">=</span> <span class="n">ENVX</span><span class="p">(</span><span class="n">ENVX</span><span class="p">(</span><span class="n">curenv</span><span class="o">-&gt;</span><span class="n">env_id</span><span class="p">));</span>

  <span class="k">for</span> <span class="p">(</span> <span class="p">;</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">NENV</span><span class="p">;</span><span class="n">i</span> <span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">nxt</span> <span class="o">=</span> <span class="p">(</span><span class="n">nxt</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">NENV</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">envs</span><span class="p">[</span><span class="n">nxt</span><span class="p">].</span><span class="n">env_status</span> <span class="o">==</span> <span class="n">ENV_RUNNABLE</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">idle</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">envs</span><span class="p">[</span><span class="n">nxt</span><span class="p">];</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">idle</span><span class="p">)</span> 
    <span class="n">env_run</span><span class="p">(</span><span class="n">idle</span><span class="p">);</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">curenv</span> <span class="o">&amp;&amp;</span> <span class="n">curenv</span><span class="o">-&gt;</span><span class="n">env_status</span> <span class="o">==</span> <span class="n">ENV_RUNNING</span><span class="p">)</span>
    <span class="n">env_run</span><span class="p">(</span><span class="n">curenv</span><span class="p">);</span>

  <span class="c1">// sched_halt never returns</span>
  <span class="n">sched_halt</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>


<p>同时在syscall中添加sys_yield()系统调用。sys_yield通过调用 sche_yield 实现。</p>
<h4>Question 3</h4>
<p>因为所有user 的env的页表的初始化都是通过 memmove(e-&gt;env_pgdir, kern_pgdir, PGSIZE); 实现的，kern_pgdir中包含了UENVS的地址空间，envs数组都是存储在UENVS这个地址上的，UENVS对user是RO，对kernel是RW，所以，即使更换为被调度的env的pgdir，也是可以访问这个虚拟地址的。</p>
<h4>Question 4</h4>
<p>old env 的registers包含了old env的运行的状态，运行到哪个eip，使用的是哪个ss，ssp等等，当这个old env被调度，继续执行的时候，需要知道之前执行到哪里了，所以是需要保存old env的registers的。</p>
<p>old env 的 reigsters 是在 trap(trapframe)中，把参数 trapframe，拷贝到 curenv-&gt;env_tf，上的，这样就保存了trap之前，env 的状态了，curenv 是在 UENV 虚拟地址上的。</p>
<div class="highlight"><pre><span class="c1">// Copy trap frame (which is currently on the stack)</span>
<span class="c1">// into &#39;curenv-&gt;env_tf&#39;, so that running the environment</span>
<span class="c1">// will restart at the trap point.</span>
<span class="c1">// now, the code is running in kernel mode, but curenv is not </span>
<span class="c1">// kernel, curenv is the env just before the trap occured.</span>
<span class="c1">// so, the trap fram copy is needed, for saving the trapped </span>
<span class="c1">// env&#39;s registers.</span>
<span class="c1">// tf is on the kernel stack.</span>
<span class="n">curenv</span><span class="o">-&gt;</span><span class="n">env_tf</span> <span class="o">=</span> <span class="o">*</span><span class="n">tf</span><span class="p">;</span>
<span class="c1">// The trapframe on the stack should be ignored from here on.</span>
<span class="n">tf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">curenv</span><span class="o">-&gt;</span><span class="n">env_tf</span><span class="p">;</span>
</pre></div>


<h3>Exercise 7</h3>
<p>实现关于 fork 的系统调用。因为是系统调用，所以对于 user 系统调用的参数的处理要谨慎，进行各种corner case 的检查，来保证在某些特殊述如下 user 不能hack kernel。</p>
<p>记住这句话：<strong>大道理谁都懂，魔鬼在细节！</strong> 在写kernel的代码的时候，要考到到各种输入的corner case。</p>
<h4>sys_exofork 的实现</h4>
<p>sys_exofork 的作用就是alloc 一个新的env，这个env 调用系统调用的孩子(curenv 就是调用这个系统调用的env)。同时将son env的寄存器的值初始化为parent env的值，这样相当于son env 也是执行到这里的，只不过son env的status 是 ENV_NOT_RUNNABLE，因为还没有初始化页表什么的，所以还是不能运行的。对于函数的返回值，如果是parent env，那么返回son env 的id，如果是son env，那么返回0。如何区分这个呢？想到系统调用的返回值是记录在trapframe 的eax寄存器中，所以，注意对son env的寄存器初始化的时候，要将son env 的eax寄存器初始化为0。</p>
<div class="highlight"><pre><span class="k">static</span> <span class="kt">envid_t</span>
<span class="nf">sys_exofork</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="n">Env</span> <span class="o">*</span><span class="n">newenv</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

  <span class="c1">// alloc </span>
  <span class="k">if</span> <span class="p">((</span><span class="n">ret</span> <span class="o">=</span> <span class="n">env_alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newenv</span><span class="p">,</span> <span class="n">curenv</span><span class="o">-&gt;</span><span class="n">env_id</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">E_NO_FREE_ENV</span><span class="p">;</span>

  <span class="c1">// set trapframe , note that son_env &#39;s eax should be zero because </span>
  <span class="c1">// son env&#39;s fork will return zero.</span>
  <span class="n">memmove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newenv</span><span class="o">-&gt;</span><span class="n">env_tf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">curenv</span><span class="o">-&gt;</span><span class="n">env_tf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">Trapframe</span><span class="p">));</span>
  <span class="n">newenv</span><span class="o">-&gt;</span><span class="n">env_tf</span><span class="p">.</span><span class="n">tf_regs</span><span class="p">.</span><span class="n">reg_eax</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="c1">// set status </span>
  <span class="n">newenv</span><span class="o">-&gt;</span><span class="n">env_status</span> <span class="o">=</span> <span class="n">ENV_NOT_RUNNABLE</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">newenv</span><span class="o">-&gt;</span><span class="n">env_id</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<h4>sys_env_set_status 的实现</h4>
<p>sys_env_set_status的功能就如名字一样，但是需要做如下的检查：</p>
<ul>
<li>envid 需要是curenv 的son。通过envid2env检查。</li>
<li>status 只能是 ENV_RUNNABLE 或者 ENV_NOT_RUNNABLE，因为这个系统调用是配合sys_exofork的。</li>
</ul>
<div class="highlight"><pre><span class="k">static</span> <span class="kt">int</span>
<span class="nf">sys_env_set_status</span><span class="p">(</span><span class="kt">envid_t</span> <span class="n">envid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">Env</span> <span class="o">*</span> <span class="n">son_env</span><span class="p">;</span>

  <span class="c1">// check validation of the envid</span>
  <span class="k">if</span><span class="p">((</span><span class="n">ret</span> <span class="o">=</span> <span class="n">envid2env</span><span class="p">(</span><span class="n">envid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">son_env</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span> 
    <span class="k">return</span> <span class="o">-</span><span class="n">E_BAD_ENV</span><span class="p">;</span>

  <span class="c1">// check status </span>
  <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">ENV_RUNNABLE</span> <span class="o">&amp;&amp;</span> <span class="n">status</span> <span class="o">!=</span> <span class="n">ENV_NOT_RUNNABLE</span><span class="p">)</span> 
    <span class="k">return</span> <span class="o">-</span><span class="n">E_INVAL</span><span class="p">;</span>

  <span class="c1">// set son_env status </span>
  <span class="n">son_env</span><span class="o">-&gt;</span><span class="n">env_status</span> <span class="o">=</span> <span class="n">status</span><span class="p">;</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<h4>sys_page_alloc 的实现</h4>
<p>sys_page_alloc的作用是初始化一个page，映射到va这个虚拟地址，对应的权限是perm。注意envid必须是son env 的id。这个是配合sys_exofork使用的，注意到sys_exofork没有初始化虚拟地址。注意：</p>
<ul>
<li>只有envid 对应的env 是 curenv 或者是curenv 的 son 才可以。</li>
<li>va 不能超过 UTOP，并且必须是PAGE对齐的。</li>
<li>perm 的权限是又限制的，比如说不能使用PTE_D。PTE_SYSCALL宏给出了可以使用的PTE的FLAG。</li>
<li>物理page初始化为zero。</li>
<li>如果插入pte失败，记得把分配的物理页回收。</li>
</ul>
<p>因为这个系统调用实现的时候，先page_alloc，分配一个新的PageInfo，然后将这个PageInfo page_insert到va上，一个副作用就是如果va对应的PageInfo存在，那么之前的PageInfo就会被unmap掉。</p>
<div class="highlight"><pre><span class="k">static</span> <span class="kt">int</span>
<span class="nf">sys_page_alloc</span><span class="p">(</span><span class="kt">envid_t</span> <span class="n">envid</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">va</span><span class="p">,</span> <span class="kt">int</span> <span class="n">perm</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">Env</span> <span class="o">*</span> <span class="n">env</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">PageInfo</span> <span class="o">*</span> <span class="n">pp</span><span class="p">;</span>

  <span class="c1">// check envid</span>
  <span class="k">if</span> <span class="p">((</span><span class="n">ret</span> <span class="o">=</span> <span class="n">envid2env</span><span class="p">(</span><span class="n">envid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">env</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">E_BAD_ENV</span><span class="p">;</span>

  <span class="c1">// check va</span>
  <span class="k">if</span> <span class="p">((</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">va</span> <span class="o">&gt;=</span> <span class="n">UTOP</span> <span class="o">||</span> <span class="n">PGOFF</span><span class="p">(</span><span class="n">va</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> 
    <span class="k">return</span> <span class="o">-</span><span class="n">E_INVAL</span><span class="p">;</span>

  <span class="c1">// check perm </span>
  <span class="k">if</span> <span class="p">(((</span><span class="n">perm</span> <span class="o">|</span> <span class="n">PTE_SYSCALL</span><span class="p">)</span> <span class="o">!=</span> <span class="n">PTE_SYSCALL</span><span class="p">)</span> <span class="o">||</span> <span class="p">((</span><span class="n">perm</span> <span class="o">|</span> <span class="n">PTE_U</span> <span class="o">|</span> <span class="n">PTE_P</span><span class="p">)</span> <span class="o">!=</span> <span class="n">perm</span><span class="p">))</span> 
    <span class="k">return</span> <span class="o">-</span><span class="n">E_INVAL</span><span class="p">;</span>

  <span class="c1">// alloc page and memset to ZERO</span>
  <span class="n">pp</span> <span class="o">=</span> <span class="n">page_alloc</span><span class="p">(</span><span class="n">ALLOC_ZERO</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pp</span><span class="p">)</span> 
    <span class="k">return</span> <span class="o">-</span><span class="n">E_NO_MEM</span><span class="p">;</span>

  <span class="c1">// insert to page table</span>
  <span class="k">if</span> <span class="p">((</span><span class="n">ret</span> <span class="o">=</span> <span class="n">page_insert</span><span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">env_pgdir</span><span class="p">,</span> <span class="n">pp</span><span class="p">,</span> <span class="n">va</span><span class="p">,</span> <span class="n">perm</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span>
    <span class="n">page_free</span><span class="p">(</span><span class="n">pp</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">E_NO_MEM</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<h4>sys_page_map 的实现</h4>
<p>sys_page_map 的作用是将 srcenvid 中的 srcva 对应的内容 复制到 dstenvid 中的 dstva 中，同时将权限更新为perm。注意：</p>
<ul>
<li>凡是涉及到envid，就要检查envid 的有效性，只有curenv 的 id 是这个envid 或者 curenv 的直接相连的 son env 的 id 是这个 envid 的时候才能够访问。</li>
<li>系统调用中凡是涉及到虚拟地址空间，都要检查这个user是否有访问这个虚拟地址空间的权限。比如va不能够超过 UTOP。</li>
<li>凡是涉及到虚拟地址空间的，创建这个va的page的时候，注意这个va是否已经被占用了。</li>
<li>凡是涉及到页表权限FLAG的，都要检查user是否有这个权限设置这个FLAG。</li>
</ul>
<div class="highlight"><pre><span class="k">static</span> <span class="kt">int</span>
<span class="nf">sys_page_map</span><span class="p">(</span><span class="kt">envid_t</span> <span class="n">srcenvid</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">srcva</span><span class="p">,</span>
       <span class="kt">envid_t</span> <span class="n">dstenvid</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dstva</span><span class="p">,</span> <span class="kt">int</span> <span class="n">perm</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="n">Env</span> <span class="o">*</span><span class="n">srcenv</span><span class="p">,</span> <span class="o">*</span><span class="n">dstenv</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">PageInfo</span> <span class="o">*</span> <span class="n">pp</span><span class="p">;</span>
  <span class="kt">pte_t</span> <span class="o">*</span> <span class="n">src_pte</span><span class="p">;</span>

  <span class="c1">// check srcenvid and dstenvid</span>
  <span class="k">if</span> <span class="p">((</span><span class="n">ret</span> <span class="o">=</span> <span class="n">envid2env</span><span class="p">(</span><span class="n">srcenvid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">srcenv</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">((</span><span class="n">ret</span> <span class="o">=</span> <span class="n">envid2env</span><span class="p">(</span><span class="n">dstenvid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dstenv</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

  <span class="c1">// check srcva and dstva</span>
  <span class="k">if</span> <span class="p">((</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">srcva</span> <span class="o">&gt;=</span> <span class="n">UTOP</span> <span class="o">||</span> <span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">dstva</span> <span class="o">&gt;=</span> <span class="n">UTOP</span> <span class="o">||</span> <span class="n">PGOFF</span><span class="p">(</span><span class="n">srcva</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">PGOFF</span><span class="p">(</span><span class="n">dstva</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">E_INVAL</span><span class="p">;</span>

  <span class="c1">// check srcva is mapped in srcenv or not</span>
  <span class="n">pp</span> <span class="o">=</span> <span class="n">page_lookup</span><span class="p">(</span><span class="n">srcenv</span><span class="o">-&gt;</span><span class="n">env_pgdir</span><span class="p">,</span> <span class="n">srcva</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">src_pte</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pp</span><span class="p">)</span> 
    <span class="k">return</span> <span class="o">-</span><span class="n">E_INVAL</span><span class="p">;</span>

  <span class="c1">// check perm </span>
  <span class="k">if</span> <span class="p">(((</span><span class="n">perm</span> <span class="o">|</span> <span class="n">PTE_SYSCALL</span><span class="p">)</span> <span class="o">!=</span> <span class="n">PTE_SYSCALL</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="n">src_pte</span> <span class="o">&amp;</span> <span class="n">PTE_W</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">perm</span> <span class="o">&amp;</span> <span class="n">PTE_W</span><span class="p">)))</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">E_INVAL</span><span class="p">;</span>

  <span class="c1">// do page map</span>
  <span class="k">if</span> <span class="p">((</span><span class="n">ret</span> <span class="o">=</span> <span class="n">page_insert</span><span class="p">(</span><span class="n">dstenv</span><span class="o">-&gt;</span><span class="n">env_pgdir</span><span class="p">,</span> <span class="n">pp</span><span class="p">,</span> <span class="n">dstva</span><span class="p">,</span> <span class="n">perm</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">E_NO_MEM</span><span class="p">;</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<h4>sys_page_unmap 的实现</h4>
<p>sys_page_unmap的功能就是释放envid对应的虚拟地址空间va。注意检查参数。</p>
<div class="highlight"><pre><span class="k">static</span> <span class="kt">int</span>
<span class="nf">sys_page_unmap</span><span class="p">(</span><span class="kt">envid_t</span> <span class="n">envid</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">va</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">Env</span> <span class="o">*</span><span class="n">env</span><span class="p">;</span>

  <span class="c1">// check envid </span>
  <span class="k">if</span> <span class="p">((</span><span class="n">ret</span> <span class="o">=</span> <span class="n">envid2env</span><span class="p">(</span><span class="n">envid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">env</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">E_BAD_ENV</span><span class="p">;</span>

  <span class="c1">// check va</span>
  <span class="k">if</span> <span class="p">((</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">va</span> <span class="o">&gt;=</span> <span class="n">UTOP</span> <span class="o">||</span> <span class="p">(</span><span class="n">PGOFF</span><span class="p">(</span><span class="n">va</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">E_INVAL</span><span class="p">;</span>

  <span class="c1">// do page unmap</span>
  <span class="n">page_remove</span><span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">env_pgdir</span><span class="p">,</span> <span class="n">va</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<h3>利用刚刚完成的系统调用在用户态实现简单的 fork</h3>
<p>在user/dumbfork.c 中实现的dumbfork，没有实现COW，过程如下:</p>
<div class="highlight"><pre><span class="c1">// 这段代码是user的代码，在user态执行。</span>
<span class="kt">envid_t</span>
<span class="nf">dumbfork</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">envid_t</span> <span class="n">envid</span><span class="p">;</span>
  <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
  <span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">end</span><span class="p">[];</span>

  <span class="c1">// Allocate a new child environment.</span>
  <span class="c1">// The kernel will initialize it with a copy of our register state,</span>
  <span class="c1">// so that the child will appear to have called sys_exofork() too -</span>
  <span class="c1">// except that in the child, this &quot;fake&quot; call to sys_exofork()</span>
  <span class="c1">// will return 0 instead of the envid of the child.</span>
  <span class="n">envid</span> <span class="o">=</span> <span class="n">sys_exofork</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">envid</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">panic</span><span class="p">(</span><span class="s">&quot;sys_exofork: %e&quot;</span><span class="p">,</span> <span class="n">envid</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">envid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// We&#39;re the child.</span>
    <span class="c1">// The copied value of the global variable &#39;thisenv&#39;</span>
    <span class="c1">// is no longer valid (it refers to the parent!).</span>
    <span class="c1">// Fix it and return 0.</span>
    <span class="c1">// 这里的thisenv不是 kernel 中的每个CPU的thisenv，每个 CPU 中的</span>
    <span class="c1">// thisenv一定是正在运行的env，因为在调度的时候会更新curenv的值。</span>
    <span class="c1">// 这里的thisenv是 lib 中记录的当前的env。</span>
    <span class="n">thisenv</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">envs</span><span class="p">[</span><span class="n">ENVX</span><span class="p">(</span><span class="n">sys_getenvid</span><span class="p">())];</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// We&#39;re the parent.</span>
  <span class="c1">// Eagerly copy our entire address space into the child.</span>
  <span class="c1">// This is NOT what you should do in your fork implementation.</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="o">*</span><span class="p">)</span> <span class="n">UTEXT</span><span class="p">;</span> <span class="n">addr</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="n">addr</span> <span class="o">+=</span> <span class="n">PGSIZE</span><span class="p">)</span>
    <span class="n">duppage</span><span class="p">(</span><span class="n">envid</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>

  <span class="c1">// Also copy the stack we are currently running on.</span>
  <span class="n">duppage</span><span class="p">(</span><span class="n">envid</span><span class="p">,</span> <span class="n">ROUNDDOWN</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="n">PGSIZE</span><span class="p">));</span>

  <span class="c1">// Start the child environment running</span>
  <span class="k">if</span> <span class="p">((</span><span class="n">r</span> <span class="o">=</span> <span class="n">sys_env_set_status</span><span class="p">(</span><span class="n">envid</span><span class="p">,</span> <span class="n">ENV_RUNNABLE</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">panic</span><span class="p">(</span><span class="s">&quot;sys_env_set_status: %e&quot;</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">envid</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<h4>如何通过这些系统调用实现duppage？</h4>
<p>通过 sys_page_map， sys_page_unmap， memmove 把当前env上的va上的内容，复制到son env上对应的va上？ <strong>parent env 是无法直接访问son env的地址空间的。</strong></p>
<p>在这里首先不得不感叹一下JOS的设计哲学，这些系统调用的函数实现功能的<strong>粒度恰到好处</strong>。没有一个系统调用的实现是有重复的。如果让我来解决这个问题，可能直接就是简单粗暴的加一个系统调用，能够将一个env的va上的内容复制到另一个env的va上，但是这两个env是要有检查parent关系的。但是这样显然就和前面的系统调用有重复实现的部分了。说几点细节：</p>
<ul>
<li>sys_page_alloc : parent env 可以通过这个系统调用来给son env分配一个虚拟地址和对应的物理页。</li>
<li>sys_page_map : parent env 可以在 son 的 env 中 set 一个映射：son env 的一个va 对应到 将自己的va对应的物理页上。注意：parent env的物理页被两个va映射了。</li>
<li>sys_page_unmap : parent env可以通过这个系统调用，将son env的一个 PTE 从PageTable中删除掉，同时decref对应的物理页。</li>
</ul>
<p>方法如下：</p>
<ol>
<li>parent env 是可以通过调用 sys_page_alloc 来给son env 分配一个虚拟地址和这个虚拟地址对应的物理页的。所以首先在 son env 上分配这样一个虚拟地址。</li>
<li>在parent env中设置一个临时的虚拟地址tmpva，将son env的va 通过 sys_page_map，映射到parent tmpva 对应的物理页上。tmpva对应的物理页refcount = 2.</li>
<li>通过memmove，将parent env 中的va对应的内容复制到 tmpva上。</li>
<li>在parent env中sys_page_unmap 自己的tmpva。这样tmpva对应的物理页的refcount 就是1了，是son va引用的。</li>
</ol>
<div class="highlight"><pre><span class="c1">// 这段代码是user的，在user态执行。</span>
<span class="c1">// dup当前env的 addr 到 destenv的addr 上。</span>
<span class="kt">void</span>
<span class="nf">duppage</span><span class="p">(</span><span class="kt">envid_t</span> <span class="n">dstenv</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

  <span class="c1">// This is NOT what you should do in your fork.</span>
  <span class="k">if</span> <span class="p">((</span><span class="n">r</span> <span class="o">=</span> <span class="n">sys_page_alloc</span><span class="p">(</span><span class="n">dstenv</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">PTE_P</span><span class="o">|</span><span class="n">PTE_U</span><span class="o">|</span><span class="n">PTE_W</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">panic</span><span class="p">(</span><span class="s">&quot;sys_page_alloc: %e&quot;</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">((</span><span class="n">r</span> <span class="o">=</span> <span class="n">sys_page_map</span><span class="p">(</span><span class="n">dstenv</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">UTEMP</span><span class="p">,</span> <span class="n">PTE_P</span><span class="o">|</span><span class="n">PTE_U</span><span class="o">|</span><span class="n">PTE_W</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">panic</span><span class="p">(</span><span class="s">&quot;sys_page_map: %e&quot;</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
  <span class="n">memmove</span><span class="p">(</span><span class="n">UTEMP</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">PGSIZE</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">((</span><span class="n">r</span> <span class="o">=</span> <span class="n">sys_page_unmap</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">UTEMP</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">panic</span><span class="p">(</span><span class="s">&quot;sys_page_unmap: %e&quot;</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>-- EOF --</p>
            </div>
            <!-- /.entry-content -->
        </article>
    </section>

        </div>
    </div>
</div>
<footer>
   <div class="container">
      <hr>
      <div class="row">
         <div class="col-xs-10">&copy; 2013 zorksylar
            &middot; Powered by <a href="https://github.com/DandyDev/pelican-bootstrap3" target="_blank">pelican-bootstrap3</a>,
            <a href="http://docs.getpelican.com/" target="_blank">Pelican</a>,
            <a href="http://getbootstrap.com" target="_blank">Bootstrap</a>         </div>
         <div class="col-xs-2"><p class="pull-right"><i class="fa fa-arrow-up"></i> <a href="#">Back to top</a></p></div>
      </div>
   </div>
</footer>
<script src="http://zorksylar.github.io/theme/js/jquery.min.js"></script>

<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="http://zorksylar.github.io/theme/js/bootstrap.min.js"></script>

<!-- Enable responsive features in IE8 with Respond.js (https://github.com/scottjehl/Respond) -->
<script src="http://zorksylar.github.io/theme/js/respond.min.js"></script>


</body>
</html>